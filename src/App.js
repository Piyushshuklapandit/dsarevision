import React, { useState } from "react";
import "./App.css";

const data = [
  { id: 1, marks: 2, question: "What is an algorithm?", answer: "An algorithm is a finite set of well-defined instructions that provide a solution to a problem or perform a specific task." },
  { id: 2, marks: 2, question: "Define time complexity.", answer: "Time complexity is the computational complexity that describes the amount of time an algorithm takes to run, relative to the size of the input." },
  { id: 3, marks: 2, question: "What is space complexity?", answer: "Space complexity measures the total amount of memory used by an algorithm in terms of the size of the input." },
  { id: 4, marks: 2, question: "Differentiate between an array and a linked list.", answer: "An array stores elements in contiguous memory locations, while a linked list stores elements in nodes, with each node pointing to the next." },
  { id: 5, marks: 2, question: "Explain FIFO and LIFO.", answer: "FIFO (First In, First Out) is used in queues, where the first element added is the first to be removed. LIFO (Last In, First Out) is used in stacks, where the last element added is the first to be removed." },
  { id: 6, marks: 7, question: "Explain Quick Sort with an example.", answer: "Quick Sort is a divide-and-conquer algorithm where an element, called a pivot, is chosen and the array is partitioned around it. Each subarray is then sorted recursively. For example, for the array [10, 7, 8, 9, 1, 5], if 10 is chosen as the pivot, the array is rearranged as [7, 8, 9, 1, 5] | 10 | [], and then each subarray is sorted." },
  { id: 7, marks: 7, question: "Describe different types of trees.", answer: "Types of trees include: 1) Binary Tree: Each node has at most two children. 2) Binary Search Tree (BST): A binary tree where the left child is smaller and the right child is larger. 3) AVL Tree: A self-balancing binary search tree. 4) Red-Black Tree: A self-balancing binary search tree with extra properties for balancing. 5) B-Tree: A self-balancing search tree commonly used in databases." },
  { id: 8, marks: 7, question: "Explain Dijkstra’s Algorithm with an example.", answer: "Dijkstra’s Algorithm finds the shortest path from a source vertex to all other vertices in a weighted graph. It uses a priority queue to select the vertex with the smallest tentative distance. For example, in a graph with vertices A, B, and C, the algorithm will progressively update the shortest paths from the source vertex to all other vertices." },
  { id: 9, marks: 7, question: "Write an algorithm to convert infix to postfix expression.", answer: "1. Initialize an empty stack for operators. 2. For each character in the infix expression: - If it's an operand, add it to the output. - If it's an operator, pop operators from the stack to the output while they have higher or equal precedence, then push the current operator onto the stack. - If it's a parenthesis, handle it accordingly. 3. Pop any remaining operators from the stack to the output." },
  { id: 10, marks: 7, question: "Explain Hashing and its techniques.", answer: "Hashing is a technique that uses a hash function to map data to a fixed-size value, which helps in faster data retrieval. Techniques include: 1) Direct Hashing: Maps keys directly to indices. 2) Chaining: Handles collisions using linked lists. 3) Open Addressing: Resolves collisions by probing for an empty slot." },
  { id: 11, marks: 2, question: "What is a heap data structure?", answer: "A heap is a complete binary tree that satisfies the heap property, where each parent node is greater than or equal to its children in a max heap or less than or equal to its children in a min heap." },
  { id: 12, marks: 2, question: "Define AVL tree.", answer: "An AVL tree is a self-balancing binary search tree in which the height difference between the left and right subtrees of any node is at most one." },
  { id: 13, marks: 2, question: "What is a circular queue?", answer: "A circular queue is a linear data structure that follows the FIFO principle and connects the last position back to the first position to make efficient use of space." },
  { id: 14, marks: 2, question: "What is a spanning tree?", answer: "A spanning tree of a graph is a subgraph that includes all the vertices of the original graph with the minimum number of edges, and no cycles." },
  { id: 15, marks: 2, question: "Explain depth-first search (DFS).", answer: "DFS is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It is implemented using a stack." },
  { id: 16, marks: 7, question: "Explain Kruskal’s Algorithm with an example.", answer: "Kruskal’s Algorithm finds the minimum spanning tree (MST) by sorting the edges and adding them one by one, ensuring no cycles are formed. For example, given a graph with vertices A, B, C, and edges AB, AC, BC, Kruskal’s algorithm will sort the edges by weight and add them if they don’t form a cycle." },
  { id: 17, marks: 7, question: "What is Floyd-Warshall Algorithm?", answer: "The Floyd-Warshall Algorithm is an algorithm for finding the shortest paths between all pairs of vertices in a weighted graph. It works by iteratively improving the path estimates by considering each vertex as an intermediate point." },
  { id: 18, marks: 7, question: "Explain B-Trees and their applications.", answer: "A B-Tree is a self-balancing search tree in which nodes can have more than two children. It is used in databases and file systems for efficient searching, insertion, and deletion of large datasets." },
  { id: 19, marks: 7, question: "Describe the difference between Prim’s and Kruskal’s Algorithm.", answer: "Prim’s Algorithm starts with an arbitrary vertex and grows the MST by adding the smallest edge connected to the tree, whereas Kruskal’s Algorithm starts with all edges and adds the smallest edge to the MST that doesn’t form a cycle." },
  { id: 20, marks: 7, question: "Explain Trie data structure and its applications.", answer: "A Trie is a tree-like data structure used for storing a dynamic set of strings, where each node represents a character of a string. It is commonly used in applications like autocomplete and dictionary implementations." },
  { id: 21, marks: 2, question: "What is a priority queue?", answer: "A priority queue is a data structure where each element is assigned a priority, and elements are dequeued in order of their priority." },
  { id: 22, marks: 2, question: "Define graph traversal.", answer: "Graph traversal refers to the process of visiting all the vertices in a graph in a systematic manner, typically using algorithms like BFS or DFS." },
  { id: 23, marks: 7, question: "Explain Bellman-Ford Algorithm.", answer: "The Bellman-Ford Algorithm finds the shortest path from a single source vertex to all other vertices in a graph, and can handle graphs with negative weight edges." },
  { id: 24, marks: 7, question: "Describe the structure of a binary search tree.", answer: "A Binary Search Tree (BST) is a tree where each node has at most two children, with the left child smaller than the parent node and the right child larger than the parent node." },
  { id: 25, marks: 7, question: "Explain the concept of dynamic programming.", answer: "Dynamic programming is an optimization technique that solves problems by breaking them into overlapping subproblems and solving each subproblem only once, storing the results for future use." },
  { id: 26, marks: 2, question: "What is a doubly linked list?", answer: "A doubly linked list is a type of linked list where each node has two pointers: one pointing to the next node and another pointing to the previous node." },
  { id: 27, marks: 2, question: "What is an adjacency matrix?", answer: "An adjacency matrix is a square matrix used to represent a graph, where the element at row i and column j indicates the presence or absence of an edge between vertices i and j." },
  { id: 28, marks: 2, question: "What is a stack?", answer: "A stack is a linear data structure that follows the Last In First Out (LIFO) principle." },
  { id: 29, marks: 2, question: "Explain the concept of a queue.", answer: "A queue is a linear data structure that follows the First In First Out (FIFO) principle." },
  { id: 30, marks: 2, question: "What is a linked list?", answer: "A linked list is a linear data structure where elements are stored in nodes, and each node points to the next node." },
  { id: 31, marks: 7, question: "Explain Merge Sort with an example.", answer: "Merge Sort is a divide-and-conquer algorithm that divides the array into two halves, recursively sorts them, and merges the sorted halves." },
  { id: 32, marks: 7, question: "Describe different types of graphs.", answer: "Types of graphs include Directed Graphs, Undirected Graphs, Weighted Graphs, and Bipartite Graphs." },
  { id: 33, marks: 7, question: "What is Prim's Algorithm?", answer: "Prim’s Algorithm is a greedy algorithm used to find the Minimum Spanning Tree (MST) of a connected, undirected graph." },
  { id: 34, marks: 7, question: "Explain the concept of a dynamic array.", answer: "A dynamic array is an array that can resize itself when it reaches its capacity, allowing for efficient memory usage." },
  { id: 35, marks: 7, question: "What is a Fibonacci Heap?", answer: "A Fibonacci Heap is a data structure consisting of a collection of heap-ordered trees, providing better amortized time complexity for certain operations." },
  { id: 36, marks: 7, question: "Explain the Bellman-Ford Algorithm with an example.", answer: "The Bellman-Ford Algorithm finds the shortest path from a single source vertex to all other vertices in a graph, even with negative edge weights." },
  { id: 37, marks: 7, question: "What is a hash table?", answer: "A hash table is a data structure that maps keys to values using a hash function to quickly retrieve values based on their keys." },
  { id: 38, marks: 2, question: "What is a circular linked list?", answer: "A circular linked list is a linked list where the last node points back to the first node, forming a circular structure." },
  { id: 39, marks: 2, question: "What is the difference between a stack and a queue?", answer: "A stack follows the LIFO principle, while a queue follows the FIFO principle." },
  { id: 40, marks: 2, question: "What is an algorithmic complexity?", answer: "Algorithmic complexity refers to the study of the efficiency of an algorithm in terms of time and space requirements." },
  { id: 41, marks: 7, question: "Explain the concept of greedy algorithms with examples.", answer: "Greedy algorithms build a solution incrementally by making the locally optimal choice at each stage, such as in the Huffman Coding and Kruskal’s Algorithm." },
  { id: 42, marks: 7, question: "What is the difference between depth-first search (DFS) and breadth-first search (BFS)?", answer: "DFS explores as far as possible along each branch before backtracking, while BFS explores all neighbors at the present depth level before moving on to nodes at the next depth level." },
  { id: 43, marks: 7, question: "Explain the concept of a binary heap.", answer: "A binary heap is a complete binary tree that satisfies the heap property: the value of each node is either greater than or equal to or less than or equal to its children." },
  { id: 44, marks: 7, question: "What is an AVL tree?", answer: "An AVL tree is a self-balancing binary search tree where the difference in height between the left and right subtrees is at most 1." },
  { id: 45, marks: 7, question: "Describe the concept of memoization in dynamic programming.", answer: "Memoization is a technique where intermediate results of subproblems are stored to avoid redundant calculations in dynamic programming." },
  { id: 46, marks: 2, question: "What is an adjacency list?", answer: "An adjacency list is a collection of unordered lists used to represent a graph, where each list corresponds to a node and contains the list of adjacent nodes." },
  { id: 47, marks: 2, question: "What is the difference between directed and undirected graphs?", answer: "In a directed graph, edges have a direction, whereas in an undirected graph, edges do not have any direction." },
  { id: 48, marks: 7, question: "Explain the concept of topological sorting.", answer: "Topological sorting of a directed acyclic graph (DAG) arranges vertices in a linear order such that for every directed edge (u, v), vertex u comes before v." },
  { id: 49, marks: 7, question: "What is a Red-Black Tree?", answer: "A Red-Black Tree is a self-balancing binary search tree where each node has an extra bit for color (either red or black), used to maintain balance during insertions and deletions." },
  { id: 50, marks: 7, question: "Describe the concept of a trie data structure.", answer: "A trie is a tree-like data structure used to store a dynamic set or associative array where keys are usually strings." },
  { id: 51, marks: 2, question: "What is an algorithm?", answer: "An algorithm is a finite set of well-defined, step-by-step instructions used to perform a task or solve a problem. It typically takes input, processes the input based on its logic, and produces output. An algorithm is a fundamental concept in computer science and is used to develop software applications, solve problems, and create solutions for various tasks. It should be clear, unambiguous, and efficient." },
  
  { id: 52, marks: 2, question: "What is the difference between an array and a linked list?", answer: "An array is a collection of elements stored in contiguous memory locations, whereas a linked list consists of nodes, each containing data and a reference (or pointer) to the next node in the sequence. Arrays have a fixed size, and elements are accessed by index, providing O(1) time complexity for access. In contrast, linked lists allow dynamic resizing, and access to elements is done sequentially, which takes O(n) time. Arrays are more memory-efficient for storing a fixed set of elements, while linked lists offer greater flexibility for dynamic operations like insertion and deletion." },

  { id: 53, marks: 2, question: "What is a queue?", answer: "A queue is a linear data structure that follows the FIFO (First In, First Out) principle. This means that the element added first to the queue is the first one to be removed. The queue operates with two main operations: enqueue (insertion of elements at the rear) and dequeue (removal of elements from the front). Queues are commonly used in scenarios like managing tasks in CPU scheduling, handling requests in servers, and in breadth-first search (BFS) algorithms." },

  { id: 54, marks: 2, question: "Define Binary Search Tree (BST).", answer: "A Binary Search Tree (BST) is a type of binary tree in which each node has at most two children, referred to as the left and right children. The left child of a node contains values smaller than the node's value, and the right child contains values greater than the node's value. This property ensures that in-order traversal of a BST produces sorted values. BSTs support efficient operations like search, insertion, and deletion, all of which can be performed in O(log n) time in balanced BSTs, where n is the number of nodes." },

  { id: 55, marks: 2, question: "What is a priority queue?", answer: "A priority queue is an abstract data type that operates similarly to a regular queue but with an additional property: each element is assigned a priority. Elements with higher priority are dequeued before elements with lower priority. In a max-priority queue, the element with the highest priority is dequeued first, while in a min-priority queue, the element with the lowest priority is dequeued first. Priority queues are often implemented using heaps (binary heaps) to maintain the order of priorities efficiently. They are widely used in scheduling, task management, and in algorithms like Dijkstra's shortest path algorithm." },

  { id: 56, marks: 2, question: "What is a circular queue?", answer: "A circular queue is a variation of the linear queue where the last position is connected back to the first position, forming a circle. This overcomes the issue of a fixed-size queue becoming full even though there may be empty spaces at the front after dequeuing elements. In a circular queue, when elements are dequeued from the front and new elements are enqueued at the rear, the queue wraps around to reuse the empty spaces at the beginning. Circular queues are commonly used in buffer management, round-robin scheduling, and for handling resource allocation problems." },

  { id: 57, marks: 7, question: "Explain Quick Sort with an example.", answer: "Quick Sort is a divide-and-conquer algorithm that selects a 'pivot' element from the array and partitions the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively. Quick Sort's average time complexity is O(n log n), although in the worst case, it can be O(n^2) if the pivot selection is poor. Here's an example: Suppose the array is [10, 7, 8, 9, 1, 5]. After selecting 5 as the pivot, the array is partitioned into [1] and [10, 7, 8, 9]. The same process is repeated recursively for both sub-arrays until the entire array is sorted." },

  { id: 58, marks: 7, question: "Explain Merge Sort and its working.", answer: "Merge Sort is a stable, divide-and-conquer algorithm that divides the input array into two halves, recursively sorts each half, and then merges the sorted halves back together. The algorithm operates in O(n log n) time in all cases, making it an efficient sorting algorithm for large datasets. The key operation in merge sort is merging: two sorted subarrays are combined into a single sorted array. Merge Sort is particularly useful for external sorting, where the data doesn't fit into memory and must be stored in external storage." },

  { id: 59, marks: 7, question: "Explain Dijkstras Algorithm with an example.", answer: "Dijkstra’s Algorithm is a greedy algorithm used to find the shortest path between two nodes in a weighted graph. It assigns a tentative distance value to each node, starting with the source node. It then repeatedly selects the node with the smallest tentative distance, explores its neighbors, and updates their tentative distances. This process continues until all nodes have been visited or the destination node is reached. Example: In a graph with nodes A, B, and C and edges (A, B) = 5, (B, C) = 2, and (A, C) = 10, Dijkstra's algorithm would first select node A, then explore B and C, ultimately finding the shortest path to C." },

  { id: 60, marks: 7, question: "Explain Prims Algorithm with an example.", answer: "Prim’s Algorithm is a greedy algorithm used to find the Minimum Spanning Tree (MST) of a connected, weighted graph. It starts from any arbitrary node, then repeatedly adds the edge with the smallest weight that connects a node in the MST to a node outside of it, ensuring no cycles are formed. Example: In a graph with nodes A, B, C, and D, and edges (A, B) = 4, (A, C) = 2, (B, C) = 3, and (C, D) = 5, Prim’s algorithm would start at node A, add edge (A, C), then add edge (C, B), and finally add edge (C, D), thus creating the MST." },

  { id: 61, marks: 7, question: "Write an algorithm to convert infix to postfix expression.", answer: "To convert an infix expression (e.g., A + B) to a postfix expression (e.g., AB+), a stack is used to hold operators and operands are output directly. The algorithm follows these steps: 1) If the token is an operand, output it. 2) If the token is an operator, pop operators from the stack and output them until the top of the stack contains an operator of lower precedence, then push the current operator. 3) If the token is a left parenthesis, push it to the stack. 4) If the token is a right parenthesis, pop and output all operators from the stack until a left parenthesis is encountered. Finally, pop and output all operators from the stack." },

  { id: 62, marks: 7, question: "Describe the structure and operations of a Binary Search Tree (BST).", answer: "A Binary Search Tree (BST) is a binary tree where each node has at most two children. It follows the property that for every node, the left child’s value is less than the node’s value, and the right child’s value is greater than the node’s value. The main operations on a BST include: 1) **Search**: Starting from the root, recursively search for a value by comparing with the current node. 2) **Insertion**: Insert a value by traversing the tree to find the appropriate leaf position. 3) **Deletion**: Remove a node by adjusting the tree to maintain the BST property. 4) **Traversal**: In-order traversal of a BST produces the nodes in sorted order." },
    { id: 63, marks: 2, question: "What is a stack?", answer: "A stack is a linear data structure that follows the LIFO (Last In, First Out) principle. The last element added to the stack is the first one to be removed. Stacks are used for managing function calls, expression evaluation, and undo/redo operations. The two primary operations in a stack are push (adding an element) and pop (removing an element)." },
    
    { id: 64, marks: 2, question: "What is a linked list?", answer: "A linked list is a linear data structure where elements (called nodes) are stored in a sequence, and each node contains data and a reference (or pointer) to the next node. Linked lists allow efficient insertion and deletion of elements compared to arrays. They can be singly or doubly linked, with singly linked lists having references only to the next node and doubly linked lists having references to both the next and previous nodes." },
  
    { id: 65, marks: 2, question: "What are the types of Linked Lists?", answer: "There are three main types of linked lists: 1) **Singly Linked List**: Each node has data and a reference to the next node. 2) **Doubly Linked List**: Each node has data, a reference to the next node, and a reference to the previous node. 3) **Circular Linked List**: The last node in the list points back to the first node, forming a circular structure." },
  
    { id: 66, marks: 2, question: "What is a hash table?", answer: "A hash table is a data structure that stores key-value pairs and uses a hash function to compute an index (hash) where the value is stored. Hash tables provide average O(1) time complexity for search, insertion, and deletion operations. Collisions, where two keys hash to the same index, are handled by techniques like chaining or open addressing." },
  
    { id: 67, marks: 2, question: "What is a heap?", answer: "A heap is a specialized binary tree-based data structure that satisfies the heap property. In a **max heap**, for every node, the value is greater than or equal to its children, and in a **min heap**, the value is less than or equal to its children. Heaps are commonly used in implementing priority queues, where the highest (or lowest) priority element is always at the root." },
  
    { id: 68, marks: 7, question: "Explain the working of BFS (Breadth-First Search).", answer: "BFS is a graph traversal algorithm that explores all the vertices of a graph level by level. It starts at a given node (source node) and visits all its neighbors before moving to the next level of nodes. BFS uses a queue to keep track of the nodes to be explored. The algorithm continues to explore the graph by dequeuing nodes from the queue, visiting their neighbors, and adding them to the queue if they haven't been visited before. BFS is used in finding the shortest path in an unweighted graph." },
  
    { id: 69, marks: 7, question: "Explain the working of DFS (Depth-First Search).", answer: "DFS is a graph traversal algorithm that explores a graph by going as deep as possible along a branch before backtracking. It starts at a given node (source node) and explores as far as possible along each branch before backtracking. DFS can be implemented using a stack (iterative) or recursively. It is used for tasks like topological sorting and finding connected components in a graph." },
  
    { id: 70, marks: 7, question: "Explain the Bellman-Ford algorithm.", answer: "The Bellman-Ford algorithm is a graph algorithm used to find the shortest path from a source node to all other nodes in a weighted graph. It works by repeatedly relaxing all the edges, which means updating the shortest known distance to each node. The algorithm can handle graphs with negative weight edges, but it cannot handle negative weight cycles. The time complexity of the Bellman-Ford algorithm is O(V * E), where V is the number of vertices and E is the number of edges." },
  
    { id: 71, marks: 7, question: "What are AVL Trees?", answer: "An AVL (Adelson-Velsky and Landis) tree is a self-balancing binary search tree. In an AVL tree, the height of the two subtrees of any node differs by at most one. This balance property ensures that the tree remains approximately balanced, providing O(log n) time complexity for search, insertion, and deletion operations. When an insertion or deletion operation causes the tree to become unbalanced, rotations are performed to restore balance." },
  
    { id: 72, marks: 7, question: "Explain the working of Floyd-Warshall Algorithm.", answer: "The Floyd-Warshall algorithm is used to find the shortest paths between all pairs of nodes in a weighted graph. The algorithm uses dynamic programming to iteratively update the shortest path estimates by considering each node as an intermediate vertex and updating the shortest paths between all pairs of nodes. It has a time complexity of O(V^3), where V is the number of vertices. Floyd-Warshall can handle graphs with negative weight edges but not negative weight cycles." },
  
    { id: 73, marks: 7, question: "Explain Kruskal's Algorithm.", answer: "Kruskal's algorithm is a greedy algorithm used to find the Minimum Spanning Tree (MST) of a connected, undirected graph. It works by sorting all edges in the graph in non-decreasing order of weight and then adding the smallest edge to the MST, provided it doesn't form a cycle. The algorithm continues until the MST contains all vertices. Kruskal's algorithm is often implemented using a disjoint-set data structure to efficiently check for cycles." },
  
    { id: 74, marks: 7, question: "What are the advantages of using Dynamic Programming?", answer: "Dynamic Programming (DP) is a method for solving problems by breaking them down into smaller subproblems and storing the solutions to subproblems to avoid redundant calculations. The key advantages of DP are: 1) **Optimal Substructure**: Problems can be solved by combining solutions to smaller subproblems. 2) **Overlapping Subproblems**: Subproblems recur, so their solutions are stored to avoid redundant calculations. DP is used in problems like shortest path finding, knapsack, and Fibonacci series computation." },
  
    { id: 75, marks: 7, question: "Explain the concept of backtracking.", answer: "Backtracking is a problem-solving technique where a solution is built incrementally, and if at any point the current solution is found to be invalid, the algorithm backtracks to the previous step and tries another option. Backtracking is used in problems like puzzles, combinatorics, and constraint satisfaction. It is often applied in problems like solving Sudoku, the N-Queens problem, and finding the subsets of a set." },
  
    { id: 76, marks: 7, question: "What is Dynamic Memory Allocation?", answer: "Dynamic memory allocation is the process of allocating memory at runtime, rather than at compile time. This is typically done using functions like malloc(), calloc(), realloc(), and free() in C. Dynamic memory allocation allows for more efficient memory use, as the size of the memory needed can be determined during program execution. However, it requires careful management to avoid memory leaks, where memory is not properly freed after use." },
  
    { id: 77, marks: 7, question: "What is a function pointer?", answer: "A function pointer is a pointer that points to a function instead of a variable. It allows functions to be passed as arguments, enabling dynamic function calls. Function pointers are commonly used in situations like callback functions, where a function is called in response to an event. In C, function pointers are declared using the following syntax: `return_type (*pointer_name)(parameter_types);`." },
  
    { id: 78, marks: 7, question: "What are the different types of sorting algorithms?", answer: "There are several types of sorting algorithms, including: 1) **Bubble Sort**: A simple comparison-based algorithm where adjacent elements are swapped to sort the array. 2) **Insertion Sort**: Builds the sorted array one element at a time by inserting each element into its correct position. 3) **Selection Sort**: Repeatedly selects the smallest element and swaps it with the first unsorted element. 4) **Merge Sort**: A divide-and-conquer algorithm that splits the array and merges the sorted parts. 5) **Quick Sort**: A divide-and-conquer algorithm that selects a pivot element and partitions the array around it." },
  
    { id: 79, marks: 7, question: "What is an open addressing in hashing?", answer: "Open addressing is a collision resolution technique in hashing where, in the event of a collision (i.e., when two keys hash to the same index), the algorithm looks for the next available position in the hash table. There are different methods of open addressing, including linear probing, quadratic probing, and double hashing. Open addressing ensures that all elements are stored within the table itself, unlike chaining, which uses linked lists to handle collisions." },
  
    { id: 80, marks: 7, question: "What is the difference between a stack and a queue?", answer: "A stack and a queue are both linear data structures, but they differ in how elements are inserted and removed: 1) **Stack**: Follows the LIFO (Last In, First Out) principle, where the last element added is the first to be removed. Operations: push (insert), pop (remove). 2) **Queue**: Follows the FIFO (First In, First Out) principle, where the first element added is the first to be removed. Operations: enqueue (insert), dequeue (remove). Stacks are used for recursion and undo operations, while queues are used for scheduling tasks and managing requests." },
  
    { id: 81, marks: 7, question: "What is a hash function?", answer: "A hash function is a function that takes an input (or 'key') and maps it to a fixed-size value, typically used for indexing in hash tables. The goal of a hash function is to distribute the keys uniformly across the table to minimize collisions. A good hash function should minimize the number of collisions, produce a uniform distribution, and be fast to compute." },
  
    { id: 82, marks: 7, question: "What is the time complexity of quicksort?", answer: "The time complexity of quicksort is O(n log n) on average, where n is the number of elements. However, in the worst case (when the pivot is always the smallest or largest element), the time complexity becomes O(n^2). This worst-case scenario can be avoided by choosing a good pivot, such as the median or by using randomized quicksort." },
  
    { id: 83, marks: 7, question: "What is the time complexity of merge sort?", answer: "Merge sort has a time complexity of O(n log n) in all cases: best, average, and worst. This makes it a highly efficient sorting algorithm, especially for large datasets. Merge sort divides the array into two halves, recursively sorts each half, and then merges the sorted halves, maintaining the O(n log n) time complexity." },
  
    { id: 84, marks: 7, question: "What is a circular queue?", answer: "A circular queue is a type of queue where the last position is connected back to the first position, forming a circle. This circular structure allows for efficient use of memory because once the front elements are dequeued, the space can be reused by enqueuing new elements at the rear. In a circular queue, the operations of enqueue and dequeue are handled with the same front and rear pointers that wrap around when the end of the queue is reached." },
  
    { id: 85, marks: 7, question: "Explain the insertion sort algorithm.", answer: "Insertion sort is a simple comparison-based sorting algorithm. It works by dividing the input array into two parts: a sorted part and an unsorted part. Initially, the sorted part contains just the first element. The algorithm then repeatedly picks the next element from the unsorted part and inserts it into the correct position in the sorted part. The process is repeated until the entire array is sorted. The time complexity of insertion sort is O(n^2) in the worst case but O(n) in the best case when the array is already sorted." },
  
      { id: 86, marks: 7, question: "Explain the concept of a Binary Search Tree (BST).", answer: "A Binary Search Tree (BST) is a binary tree where each node has at most two children, and the left child’s key is smaller than the parent node’s key, while the right child’s key is greater. This property allows efficient searching, insertion, and deletion, with average time complexity of O(log n). In the worst case, the time complexity can degrade to O(n) if the tree becomes unbalanced." },
    
      { id: 87, marks: 7, question: "What is Dijkstra's algorithm?", answer: "Dijkstra's algorithm is a greedy algorithm used to find the shortest path between a source node and all other nodes in a weighted graph with non-negative weights. It works by maintaining a set of visited nodes and selecting the unvisited node with the smallest known distance. The algorithm updates the shortest paths to the neighboring nodes and continues until the shortest path to all nodes is determined." },
    
      { id: 88, marks: 7, question: "What is a priority queue?", answer: "A priority queue is an abstract data structure that stores elements with associated priorities. In a priority queue, elements with higher priorities are dequeued before those with lower priorities. Priority queues can be implemented using heaps, where the root of the heap always contains the highest (or lowest) priority element. They are used in scheduling tasks, pathfinding algorithms (like Dijkstra’s), and managing resources in operating systems." },
    
      { id: 89, marks: 7, question: "What is a graph? Explain its types.", answer: "A graph is a collection of nodes (vertices) and edges (connections between nodes). There are two main types of graphs: 1) **Directed Graph (Digraph)**: Edges have a direction, going from one node to another. 2) **Undirected Graph**: Edges have no direction, meaning the connection between two nodes is bidirectional. Graphs can also be classified based on their structure: 1) **Weighted Graph**: Edges have weights representing costs or distances. 2) **Unweighted Graph**: Edges do not have weights." },
    
      { id: 90, marks: 7, question: "What are the different types of trees in data structures?", answer: "In data structures, trees are hierarchical structures consisting of nodes. Some common types of trees are: 1) **Binary Tree**: Each node has at most two children. 2) **Binary Search Tree (BST)**: A binary tree with the left child’s key smaller than the parent node, and the right child’s key greater. 3) **AVL Tree**: A self-balancing binary search tree where the difference in heights between left and right subtrees is at most 1. 4) **Heap**: A complete binary tree with a specific ordering property, such as max heap or min heap." },
    
      { id: 91, marks: 7, question: "What is the difference between a stack and a queue?", answer: "A stack and a queue are both linear data structures, but they differ in the way elements are inserted and removed. 1) **Stack**: Follows the LIFO (Last In, First Out) principle, where the last element added is the first to be removed. 2) **Queue**: Follows the FIFO (First In, First Out) principle, where the first element added is the first to be removed. Stacks are used in recursion and undo operations, while queues are used in task scheduling and handling requests." },
    
      { id: 92, marks: 7, question: "What is the difference between a linked list and an array?", answer: "A linked list and an array are both used for storing data, but they have different structures: 1) **Array**: A collection of elements stored in contiguous memory locations. It allows fast access to elements by index but has a fixed size and costly insertion/deletion. 2) **Linked List**: A collection of nodes where each node contains data and a reference to the next node. It allows dynamic size and efficient insertion/deletion but has slower access time as elements need to be traversed one by one." },
    
      { id: 93, marks: 7, question: "What is the difference between dynamic memory allocation and static memory allocation?", answer: "Static memory allocation is the process of allocating memory at compile time, before the program is executed. The size of the memory block is fixed and cannot be changed during runtime. Dynamic memory allocation, on the other hand, allocates memory at runtime using functions like malloc(), calloc(), realloc(), and free() in C. This allows flexible memory usage based on the needs of the program, but it requires careful management to avoid memory leaks." },
    
      { id: 94, marks: 7, question: "What is the purpose of a database index?", answer: "A database index is a data structure that improves the speed of data retrieval operations on a database table. It works by providing quick access to rows in the table based on the values in one or more columns. Indexes are typically created on columns that are frequently used in search conditions. While indexes improve query performance, they come with the trade-off of additional memory usage and slower insert/update operations." },
    
      { id: 95, marks: 7, question: "What is a recursion?", answer: "Recursion is a programming technique in which a function calls itself in order to solve a problem. A recursive function typically has a base case (the condition under which the function stops calling itself) and a recursive case (where the function calls itself with a reduced problem). Recursion is useful for problems that can be broken down into smaller subproblems, such as factorials, Fibonacci numbers, and tree traversals." },
    
      { id: 96, marks: 7, question: "What is the time complexity of Merge Sort?", answer: "The time complexity of Merge Sort is O(n log n) in all cases: best, average, and worst. This makes it one of the most efficient comparison-based sorting algorithms. Merge Sort works by dividing the input array into two halves, recursively sorting each half, and then merging the sorted halves back together. The merging process is linear in time, contributing to the overall O(n log n) time complexity." },
    
      { id: 97, marks: 7, question: "Explain the difference between a deep copy and a shallow copy.", answer: "A shallow copy is a copy of an object where the contents of the object (such as arrays or lists) are not copied; instead, references to the original objects are copied. Any changes made to the copied object can affect the original object. A deep copy, on the other hand, creates a completely independent copy of the object, including all objects contained within it. In a deep copy, changes to the copied object do not affect the original object." },
    
      { id: 98, marks: 7, question: "What is the time complexity of Quick Sort?", answer: "The time complexity of Quick Sort is O(n log n) on average, where n is the number of elements. However, in the worst case (when the pivot chosen is always the smallest or largest element), the time complexity becomes O(n^2). The worst-case scenario can be avoided by choosing a good pivot (like the median of elements) or using randomized quicksort." },
    
      { id: 99, marks: 7, question: "What is the difference between the pass by value and pass by reference?", answer: "In pass by value, a copy of the actual value is passed to the function, and any changes made to the parameter inside the function do not affect the original value. In pass by reference, a reference (or memory address) to the original value is passed, so any changes made to the parameter inside the function directly affect the original value." },
    
      { id: 100, marks: 7, question: "What is an AVL tree?", answer: "An AVL tree is a self-balancing binary search tree where the difference in heights of the left and right subtrees of any node is at most one. If this balance condition is violated after an insertion or deletion operation, rotations are performed to restore the balance. The key advantage of AVL trees is that they ensure logarithmic time complexity for search, insertion, and deletion operations, even in the worst case." },
      
        { id: 101, marks: 7, question: "Explain the concept of hashing and hash functions.", answer: "Hashing is a process that transforms input data into a fixed-size string of characters, which appears random. A hash function generates a hash value (hash code) based on the input, making it easier to search and retrieve data. A good hash function minimizes collisions and ensures that the hash values are evenly distributed. Hashing is commonly used in data structures like hash tables for efficient data retrieval." },
      
        { id: 102, marks: 7, question: "What is the purpose of a Trie data structure?", answer: "A Trie (or prefix tree) is a tree-like data structure that stores a dynamic set of strings, where each node represents a character of a string. It is primarily used for searching words in dictionaries, autocomplete features, and prefix-based searches. Tries allow for fast search, insert, and delete operations by utilizing the common prefixes of the strings stored in the structure." },
      
        { id: 103, marks: 7, question: "Explain the working of the Bellman-Ford algorithm.", answer: "The Bellman-Ford algorithm is used to find the shortest paths from a source node to all other nodes in a weighted graph, even if the graph contains negative weight edges. It works by iterating over all edges repeatedly, relaxing them, and updating the shortest paths until no further updates are possible. Bellman-Ford can detect negative weight cycles by checking if the distances can still be updated after V-1 iterations." },
      
        { id: 104, marks: 7, question: "What are the advantages of using dynamic programming?", answer: "Dynamic programming is an optimization technique used to solve complex problems by breaking them down into simpler overlapping subproblems. It avoids redundant calculations by storing the results of subproblems in a table (memoization or tabulation). Advantages include reducing time complexity from exponential to polynomial time, improving efficiency, and enabling the solution of problems that would be infeasible to solve with brute force." },
      
        { id: 105, marks: 7, question: "What is the difference between depth-first search (DFS) and breadth-first search (BFS)?", answer: "DFS and BFS are graph traversal algorithms. DFS explores as far as possible along each branch before backtracking, using a stack to keep track of the vertices. BFS, on the other hand, explores all the neighbors of a vertex before moving to the next level of vertices, using a queue for traversal. DFS is better for searching in deep or large trees, while BFS is ideal for finding the shortest path in unweighted graphs." },
      
        { id: 106, marks: 7, question: "Explain the concept of a circular linked list.", answer: "A circular linked list is a variation of a linked list where the last node points back to the first node, forming a circular structure. This type of linked list can be either singly or doubly linked. It is useful in applications where continuous traversal is required, such as in round-robin scheduling or implementing circular queues." },
      
        { id: 107, marks: 7, question: "What is a deadlock in operating systems?", answer: "A deadlock is a situation in a multi-tasking operating system where two or more processes are blocked forever because they are waiting for each other to release resources. The four necessary conditions for a deadlock to occur are mutual exclusion, hold and wait, no preemption, and circular wait. Deadlocks can be prevented by resource allocation strategies like avoiding circular waits and using resource hierarchies." },
      
        { id: 108, marks: 7, question: "What are the different types of file organizations?", answer: "File organization refers to the way data is stored in files. Common types include: 1) **Sequential file organization**: Data is stored in a sequential manner, ideal for batch processing. 2) **Indexed file organization**: Data is indexed by a key, allowing quick search and retrieval. 3) **Hashed file organization**: Data is stored based on a hash function, which helps in fast retrieval. 4) **Direct/Random file organization**: Data is stored at specific locations identified by a mathematical formula, offering fast access to records." },
      
        { id: 109, marks: 7, question: "What is the purpose of the Operating System?", answer: "The primary purpose of an operating system (OS) is to manage computer hardware and software resources and provide common services for computer programs. The OS acts as an intermediary between users and hardware, ensuring that resources are efficiently allocated. It handles tasks like process management, memory management, file system management, security, and communication between different programs." },
      
        { id: 110, marks: 7, question: "What are the advantages and disadvantages of multithreading?", answer: "Multithreading enables multiple threads of execution within a process, allowing for better resource utilization, improved performance on multi-core systems, and responsiveness in programs. Advantages include improved CPU utilization, parallelism, and faster execution of programs. Disadvantages include complexities in synchronization, race conditions, and difficulties in debugging and testing." },
      
        { id: 111, marks: 7, question: "What is the concept of a semaphore in process synchronization?", answer: "A semaphore is a synchronization primitive used to manage access to shared resources in concurrent programming. It is essentially an integer variable that can be manipulated using two atomic operations: **wait** (decrement) and **signal** (increment). Semaphores are used to prevent race conditions and ensure that processes do not conflict when accessing shared resources." },
      
        { id: 112, marks: 7, question: "Explain the concept of a priority scheduling algorithm.", answer: "Priority scheduling is a CPU scheduling algorithm that selects the process with the highest priority for execution. The priority of a process is typically determined by factors such as its importance, resource needs, or user-defined criteria. While the algorithm aims to ensure important processes get CPU time first, it may suffer from starvation if low-priority processes are never executed." },
      
        { id: 113, marks: 7, question: "What are the differences between primary and secondary memory?", answer: "Primary memory (also known as RAM) is the main memory of the computer that stores data and instructions that are currently in use by the CPU. It is fast and volatile, meaning it loses data when power is turned off. Secondary memory (e.g., hard drives, SSDs) is non-volatile and used for long-term storage. It is slower but offers higher capacity and retains data even when power is lost." },
      
        { id: 114, marks: 7, question: "What is a stack overflow?", answer: "A stack overflow occurs when a program's call stack exceeds its limit, usually due to excessive function calls or infinite recursion. This results in a program crash or unexpected behavior, as the stack, which stores local variables, function parameters, and return addresses, becomes overloaded. Stack overflows can be prevented by optimizing recursion and ensuring that function calls do not exceed the stack's capacity." },
      
        { id: 115, marks: 7, question: "What is the difference between synchronous and asynchronous communication?", answer: "Synchronous communication involves real-time, two-way exchange of information, where both parties must be present and wait for each other to send and receive messages (e.g., phone calls). Asynchronous communication allows for a delayed response, where one party sends a message and the other responds later (e.g., email, messaging). Asynchronous communication is more flexible, while synchronous communication allows for immediate interaction." },
      
        { id: 116, marks: 7, question: "What are the different types of database normalization?", answer: "Database normalization is the process of organizing data to avoid redundancy and improve data integrity. The most common types are: 1) **First Normal Form (1NF)**: Ensures that all columns contain atomic values and there are no repeating groups. 2) **Second Normal Form (2NF)**: Ensures 1NF and eliminates partial dependency. 3) **Third Normal Form (3NF)**: Ensures 2NF and eliminates transitive dependency. Higher normal forms, like BCNF and 4NF, further refine the structure." },
      
        { id: 117, marks: 7, question: "Explain the working of the Merge Sort algorithm.", answer: "Merge Sort is a divide-and-conquer algorithm that divides the input array into two halves, recursively sorts each half, and then merges the sorted halves back together. It works by comparing the smallest elements of each half and placing the smaller one into the merged array. The process continues until all elements are merged. Merge Sort has a time complexity of O(n log n) in all cases, making it efficient for large datasets." },
      
        { id: 118, marks: 7, question: "What is a binary heap?", answer: "A binary heap is a complete binary tree that satisfies the heap property. In a max-heap, each parent node has a value greater than or equal to its children, while in a min-heap, the parent node has a value less than or equal to its children. Heaps are used in priority queues and are implemented as arrays, with efficient operations like insertion, deletion, and finding the maximum/minimum element." },
      
        { id: 119, marks: 7, question: "What is the purpose of indexing in databases?", answer: "Indexing in databases improves the speed of data retrieval operations. An index is a data structure that maps keys to their corresponding data locations in the table. By using indexes, the database can quickly locate rows that match a given search query. However, indexes come with trade-offs, including increased storage requirements and slower performance for data modification operations (insert, update, delete)." },
      
        { id: 120, marks: 7, question: "What are the different types of searching algorithms?", answer: "Common searching algorithms include: 1) **Linear Search**: A simple algorithm that checks each element in a list sequentially. Its time complexity is O(n). 2) **Binary Search**: A more efficient algorithm that works on sorted arrays, repeatedly dividing the array in half. Its time complexity is O(log n). 3) **Hashing**: A method of searching based on hash functions, allowing for constant time complexity O(1) in ideal cases." },
        
          { id: 121, marks: 7, question: "What is the concept of time complexity and space complexity?", answer: "Time complexity is the measure of the amount of time an algorithm takes to run as a function of the input size. It is usually expressed using Big O notation (e.g., O(n), O(log n), O(n^2)). Space complexity refers to the amount of memory an algorithm uses relative to the size of the input. Both time and space complexities help in evaluating the efficiency of algorithms, guiding optimization efforts." },
        
          { id: 122, marks: 7, question: "Explain the concept of depth-first search (DFS) traversal in graphs.", answer: "Depth-first search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It uses a stack (or recursion) to track the visited nodes. DFS is particularly useful for finding connected components, solving puzzles like mazes, and topological sorting. It has a time complexity of O(V+E), where V is the number of vertices and E is the number of edges." },
        
          { id: 123, marks: 7, question: "What are the characteristics of an object-oriented programming language?", answer: "Object-oriented programming (OOP) languages are based on the concept of 'objects,' which represent instances of classes. The key characteristics of OOP include: 1) **Encapsulation**: Bundling data and methods into a single unit (class). 2) **Inheritance**: Ability of a class to inherit properties and behaviors from another class. 3) **Polymorphism**: Ability of different objects to respond to the same method call in different ways. 4) **Abstraction**: Hiding complex implementation details and showing only necessary features to the user." },
        
          { id: 124, marks: 7, question: "Explain the concept of a binary search tree (BST).", answer: "A binary search tree (BST) is a binary tree where each node has at most two children, and the left child’s value is less than the parent node’s value, while the right child’s value is greater than the parent node’s value. This property allows for efficient search, insert, and delete operations with average time complexity O(log n). However, performance can degrade if the tree becomes unbalanced." },
        
          { id: 125, marks: 7, question: "What is the difference between call by value and call by reference?", answer: "In call by value, a copy of the argument is passed to the function, so changes made to the parameter do not affect the original variable. In call by reference, the actual address of the argument is passed to the function, allowing modifications to the original variable. Call by reference is more efficient for large data structures like arrays or objects because it avoids copying the data." },
        
          { id: 126, marks: 7, question: "What is the difference between TCP and UDP?", answer: "TCP (Transmission Control Protocol) is a connection-oriented protocol that ensures reliable data delivery by establishing a connection between the sender and receiver, providing error checking and retransmission of lost packets. UDP (User Datagram Protocol) is a connectionless protocol, which does not guarantee reliable delivery, but it is faster and more suitable for applications like live streaming or online gaming where speed is crucial." },
        
          { id: 127, marks: 7, question: "What is the difference between stack and queue data structures?", answer: "A stack is a data structure that follows the Last-In, First-Out (LIFO) principle, where the last element added is the first to be removed. A queue follows the First-In, First-Out (FIFO) principle, where the first element added is the first to be removed. Stacks are used in function call management and undo operations, while queues are commonly used in scheduling tasks and handling requests in order." },
        
          { id: 128, marks: 7, question: "What are the advantages of using a linked list over an array?", answer: "Linked lists offer several advantages over arrays, such as: 1) **Dynamic size**: Linked lists can grow and shrink dynamically, whereas arrays have a fixed size. 2) **Efficient insertions and deletions**: Inserting or deleting elements in a linked list is more efficient as it does not require shifting elements, unlike arrays. However, linked lists have disadvantages like higher memory usage due to pointers and slower access times." },
        
          { id: 129, marks: 7, question: "Explain the concept of database transactions.", answer: "A database transaction is a sequence of operations performed as a single logical unit of work. Transactions must follow the ACID properties: 1) **Atomicity**: All operations in the transaction must complete or none at all. 2) **Consistency**: The database must transition from one valid state to another. 3) **Isolation**: Transactions should not interfere with each other. 4) **Durability**: Once a transaction is committed, its effects are permanent, even in the event of a system failure." },
        
          { id: 130, marks: 7, question: "What is the difference between static and dynamic memory allocation?", answer: "Static memory allocation occurs at compile-time, where the size of memory required is determined before execution and remains fixed during the program’s runtime. Dynamic memory allocation happens at runtime, allowing memory to be allocated and deallocated as needed using functions like malloc and free in C. Dynamic allocation offers flexibility, but it requires careful management to avoid memory leaks." },
        
          { id: 131, marks: 7, question: "What are the properties of a good hash function?", answer: "A good hash function should have the following properties: 1) **Deterministic**: The same input should always produce the same hash value. 2) **Efficient**: It should compute the hash value quickly. 3) **Uniform distribution**: It should distribute values evenly across the hash table to minimize collisions. 4) **Minimize collisions**: The likelihood of different inputs producing the same hash value should be low." },
        
          { id: 132, marks: 7, question: "What is the concept of virtual memory?", answer: "Virtual memory is a memory management technique that gives the illusion of a larger memory space than is physically available by using disk space as temporary storage. It allows programs to access more memory than is physically installed on the system by swapping data between RAM and a reserved space on the hard drive called the swap space or page file." },
        
          { id: 133, marks: 7, question: "What are the different types of operating system kernels?", answer: "There are three main types of operating system kernels: 1) **Monolithic kernel**: All the services (process management, memory management, etc.) are integrated into a single large block of code. 2) **Microkernel**: The core services are separated, with only essential components running in the kernel space, and other services run in user space. 3) **Hybrid kernel**: A combination of monolithic and microkernel architectures, balancing performance and modularity." },
        
          { id: 134, marks: 7, question: "What are the different types of file access methods?", answer: "The main types of file access methods are: 1) **Sequential access**: Data is read or written in a linear fashion from the beginning to the end. 2) **Direct access**: Data can be read or written directly at any location in the file, which is common in database systems. 3) **Indexed access**: Uses an index to allow fast search and retrieval of data from a file." },
        
          { id: 135, marks: 7, question: "Explain the working of the QuickSort algorithm.", answer: "QuickSort is a divide-and-conquer sorting algorithm that works by selecting a pivot element from the array and partitioning the other elements into two sub-arrays: one containing elements less than the pivot, and the other containing elements greater than the pivot. The sub-arrays are recursively sorted, and the result is combined to give the sorted array. QuickSort has an average time complexity of O(n log n)." },
        
          { id: 136, marks: 7, question: "What is the significance of the 'volatile' keyword in C?", answer: "The 'volatile' keyword in C is used to tell the compiler that a variable's value can change unexpectedly, often due to external factors such as hardware or concurrent processes. It prevents the compiler from optimizing or caching the value, ensuring that each access to the variable is fetched from memory rather than a register." },
        
          { id: 137, marks: 7, question: "What are the differences between a compiler and an interpreter?", answer: "A compiler translates the entire source code of a program into machine code, creating an executable file. It performs all the translation at once before execution. An interpreter, on the other hand, translates the code line-by-line during runtime, executing it directly without creating an intermediate machine code file. Compilers typically result in faster execution, while interpreters offer easier debugging and more flexibility." },
        
          { id: 138, marks: 7, question: "What is the difference between public and private keys in asymmetric encryption?", answer: "In asymmetric encryption, a pair of keys is used: 1) **Public key**: It is shared openly and used for encrypting data or verifying digital signatures. 2) **Private key**: It is kept secret and used for decrypting data or generating digital signatures. This encryption method ensures secure communication, as only the owner of the private key can decrypt the data encrypted with their public key." },
        
          { id: 139, marks: 7, question: "What is a deadlock detection algorithm?", answer: "A deadlock detection algorithm identifies whether a deadlock exists in a system where processes are competing for resources. It uses methods like wait-for graphs or resource allocation graphs to track the dependencies between processes and resources. If a cycle is detected, a deadlock is present. Some well-known algorithms include the Banker's algorithm and the resource allocation graph method." },
        
          { id: 140, marks: 7, question: "What are the different types of cloud computing models?", answer: "Cloud computing models include: 1) **Infrastructure as a Service (IaaS)**: Provides virtualized computing resources over the internet, such as virtual machines and storage. 2) **Platform as a Service (PaaS)**: Offers a platform allowing developers to build, deploy, and manage applications without worrying about the underlying infrastructure. 3) **Software as a Service (SaaS)**: Provides software applications over the internet on a subscription basis, such as Google Workspace or Microsoft Office 365." }
        
      
];


const App = () => {
  const [selectedMarks, setSelectedMarks] = useState(2);
  const [searchTerm, setSearchTerm] = useState("");
  const [bookmarked, setBookmarked] = useState([]);
  const [darkMode, setDarkMode] = useState(false);
  const [showAnswer, setShowAnswer] = useState({});
  const [progress, setProgress] = useState(0);
  
  const toggleBookmark = (id) => {
    setBookmarked((prev) => prev.includes(id) ? prev.filter((item) => item !== id) : [...prev, id]);
  };

  const toggleAnswer = (id) => {
    setShowAnswer((prev) => {
      const newShowAnswer = { ...prev, [id]: !prev[id] };
      const reviewed = Object.values(newShowAnswer).filter(Boolean).length;
      setProgress((reviewed / data.length) * 100);
      return newShowAnswer;
    });
  };

  const filteredData = data.filter((item) => item.marks === selectedMarks && item.question.toLowerCase().includes(searchTerm.toLowerCase()));

  return (
    <div className={`container ${darkMode ? "dark" : ""}`}>
      <h1>📚 Study Helper - Data Structures</h1>
      <button className="toggle-mode" onClick={() => setDarkMode(!darkMode)}>
        {darkMode ? "🌞 Light Mode" : "🌙 Dark Mode"}
      </button>
      <input type="text" placeholder="🔍 Search questions..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} />
      <div className="progress-bar">
        <div className="progress" style={{ width: `${progress}%` }}>{Math.round(progress)}%</div>
      </div>
      <div className="btn-group">
        <button onClick={() => setSelectedMarks(2)} className={selectedMarks === 2 ? "active" : ""}>2 Marks</button>
        <button onClick={() => setSelectedMarks(7)} className={selectedMarks === 7 ? "active" : ""}>7 Marks</button>
      </div>
      <div className="content">
        {filteredData.map(q => (
          <div key={q.id} className={`card ${bookmarked.includes(q.id) ? "bookmarked" : ""}`}>
            <h3 onClick={() => toggleAnswer(q.id)}>{q.question}</h3>
            {showAnswer[q.id] && <p>{q.answer}</p>}
            <button className="bookmark-btn" onClick={() => toggleBookmark(q.id)}>
              {bookmarked.includes(q.id) ? "⭐ Unbookmark" : "⭐ Bookmark"}
            </button>
          </div>
        ))}
      </div>
    </div>
  );
};

export default App;
